@*
    DirSFTP
    Copyright (C) 2023  Raphael Beck

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*@

@page "/browse"

@inject NavigationManager NavigationManager

@inject IConfigStorage ConfigStorage

<PageTitle>
    DirSFTP - @currentDirectory
</PageTitle>

@using Renci.SshNet
@using Renci.SshNet.Sftp
@using System.Collections.Concurrent;
@using GlitchedPolygons.DirSFTP.Models
@using GlitchedPolygons.DirSFTP.Services
@using GlitchedPolygons.DirSFTP.ExtensionMethods
@using GlitchedPolygons.DirSFTP.Services.Config
@using GlitchedPolygons.DirSFTP.Services.SFTP
@using GlitchedPolygons.ExtensionMethods

<h1>
    SFTP Browser
</h1>

<br />

@if (currentSftpConfig is not null)
{
    <p>
        @currentSftpConfig.Username@@@currentSftpConfig.Host:@currentSftpConfig.Port
        <span class="oi oi-account-logout"
              title="Disconnect"
              style="margin-left: 8px; cursor: pointer; font-size: 1.10rem;"
              @onclick="OnClickDisconnect">
        </span>
    </p>

    <p>
        Current directory:
    </p>

    <div class="input-group"
         style="max-width: 666px;">

        <input type="text"
               class="form-control"
               @bind="currentDirectory">

        <button class="btn btn-primary"
                type="button"
                id="go-btn"
                disabled="@busy"
                @onclick="() => OpenDirectory(currentDirectory)">
            Go
        </button>

    </div>

    <br />
}

@if (files == null)
{
    <br />

    <p>
        Loading...
    </p>

    <div class="progress"
         style="max-width: 420px">
        <div class="progress-bar progress-bar-striped progress-bar-animated"
             role="progressbar"
             aria-valuenow="100"
             aria-valuemin="0"
             aria-valuemax="100"
             style="width: 100%;">
        </div>
    </div>
}
else
{
    <table class="table table-hover @(files.Count() > 2 ? "table-striped" : "")">

        <thead>

        <tr>

            <th style="min-width: 96px">
                Actions
            </th>

            <th style="width: 66%">
                File or directory name
            </th>

            <th title="Format: yyyy-MM-dd HH:mm:ss"
                style="min-width: 192px">
                Last accessed
            </th>

            <th title="Format: yyyy-MM-dd HH:mm:ss"
                style="min-width: 192px">
                Last modified
            </th>

            <th style="min-width: 128px">
                Permissions
            </th>

            <th style="min-width: 64px">
                UID
            </th>

            <th style="min-width: 64px">
                GID
            </th>

        </tr>

        </thead>

        <tbody>

        @foreach (SftpFile file in files)
        {
            if (file.Name == "." || (file.Name == ".." && currentDirectory.Count(c => c is '/' or '\\') <= 1))
            {
                continue;
            }

            <tr>

                <td>
                    @if (file.Name != "..")
                    {
                        <span class="oi oi-trash"
                              title="Delete"
                              @onclick="() => OnClickDelete(file)">
                        </span>

                        <span class="oi oi-pencil"
                              title="Rename"
                              @onclick="() => OnClickRename(file)">
                        </span>

                        <span class="oi oi-shield"
                              title="Set permissions"
                              @onclick="() => OnClickSetPermissions(file)">
                        </span>
                    }
                </td>

                <td title="@file.FullName">

                    <a href="javascript:void(0)"
                       class="underline-on-hover"
                       @onclick="() => OnClickFile(file)">
                        @file.Name@(file.IsDirectory ? "/" : "")
                    </a>

                </td>

                <td title="@file.LastAccessTimeUtc.ToString("yyyy-MM-dd HH:mm:ss") (UTC)">
                    @file.LastAccessTime.ToString("yyyy-MM-dd HH:mm:ss")
                </td>

                <td title="@file.LastWriteTimeUtc.ToString("yyyy-MM-dd HH:mm:ss") (UTC)">
                    @file.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                </td>

                <td title="@file.ToHumanReadablePermissionMatrix()">
                    @file.ToOctalNotation()
                </td>

                <td>
                    @file.UserId
                </td>

                <td>
                    @file.GroupId
                </td>

            </tr>
        }

        </tbody>

    </table>

    <button @onclick="OnClickUpload"
            disabled="@busy"
            class="btn btn-primary mt-4 stretch-when-narrow">
        Upload
    </button>

    <span style="margin-left: 8px; margin-right: 8px;"></span>

    <button @onclick="OnClickCreateDirectory"
            disabled="@busy"
            class="btn btn-primary mt-4 stretch-when-narrow">
        Create directory
    </button>

    @if (uploadProgress.NotNullNotEmpty())
    {
        <br />
        <br />

        <p>
            <strong>Uploads:</strong>
        </p>

        @foreach (var kvp in uploadProgress)
        {
            <p>
                @kvp.Key
            </p>

            <div class="progress">
                <div class="progress-bar @((double)(kvp.Value.Item1) / (double)(kvp.Value.Item2) >= 0.999d ? "bg-success" : "progress-bar-striped progress-bar-animated")"
                     role="progressbar"
                     aria-valuenow="@kvp.Value.Item1"
                     aria-valuemin="0"
                     aria-valuemax="@kvp.Value.Item2"
                     style="width: @(((double)(kvp.Value.Item1) / (double)(kvp.Value.Item2)) * 100)%;">
                 </div>
            </div>

            <br />
        }
    }
    

    <br />
    <br />
}

@code
{
    private bool busy = false;
    private string currentDirectory = ".";
    private SftpConfig currentSftpConfig = null;
    private ISftpService sftpService = null;
    private IEnumerable<SftpFile> files = null;
    private readonly IDictionary<string, (ulong, ulong)> uploadProgress = new ConcurrentDictionary<string, (ulong, ulong)>();

    protected override async Task OnInitializedAsync()
    {
        string lastSftpConfigId = await SecureStorage.GetAsync(Constants.PreferenceIds.LAST_SFTP_CONFIG_ID);

        currentDirectory = await SecureStorage.GetAsync(Constants.PreferenceIds.LAST_DIRECTORY);

        currentSftpConfig = await ConfigStorage.Get(lastSftpConfigId);

        if (currentSftpConfig is null)
        {
            await Application.Current!.MainPage!.DisplayAlert("Please select a connection", "To browse a remote SFTP server, on the app's home page select a connection from your list of saved connections or add a new one to get started.", "OK");
            NavigationManager.NavigateTo("/");
            return;
        }

        if (currentSftpConfig.PrivateKey.NullOrEmpty() && currentSftpConfig.Password.NullOrEmpty())
        {
            string password = await Application.Current!.MainPage!.DisplayPromptAsync("Enter password", $"Please enter the password for user {currentSftpConfig.Username} on {currentSftpConfig.Host}:{currentSftpConfig.Port}\n", "Login", "Cancel");

            if (password.NullOrEmpty())
            {
                NavigationManager.NavigateTo("/");
                return;
            }
            else
            {
                currentSftpConfig.Password = password;
            }
        }

        if (currentDirectory.NullOrEmpty())
        {
            currentDirectory = currentSftpConfig.DefaultRemoteDirectory;
        }

        sftpService = new SftpService(currentSftpConfig);

        await OpenDirectory(currentDirectory);
    }

    private void OnClickDisconnect()
    {
        currentDirectory = string.Empty;

        SecureStorage.Remove(Constants.PreferenceIds.LAST_DIRECTORY);
        SecureStorage.Remove(Constants.PreferenceIds.LAST_SFTP_CONFIG_ID);

        NavigationManager.NavigateTo("/");
    }

    private async Task OnClickFile(SftpFile file)
    {
        if (file is null)
        {
            return;
        }

        if (file.IsDirectory)
        {
            if (file.Name == "..")
            {
                if (currentDirectory.Contains('\\'))
                {
                    await OpenDirectory(currentDirectory[..currentDirectory.LastIndexOf('\\')]);
                }
                else
                {
                    await OpenDirectory(currentDirectory[..currentDirectory.LastIndexOf('/')].Replace("\\", "/"));
                }

                return;
            }

            await OpenDirectory(file.FullName);
        }
        else if (file.IsRegularFile)
        {
            // TODO
        }
        else
        {            // TODO
        }
    }

    private async Task OpenDirectory(string remoteDirectory)
    {
        if (sftpService is null || currentSftpConfig is null)
        {
            return;
        }

        if (!sftpService.StillConnected)
        {
            if (Application.Current?.MainPage is not null)
            {
                await Application.Current.MainPage.DisplayAlert("Connection lost", $"Connection lost to {currentSftpConfig.Username}@{currentSftpConfig.Host}", "OK");
            }

            NavigationManager.NavigateTo("/");
            return;
        }

        if (remoteDirectory.NullOrEmpty())
        {
            remoteDirectory = ".";
        }
        else
        {
            remoteDirectory = remoteDirectory.Replace('\\', '/');
        }

        if (!sftpService.Exists(remoteDirectory))
        {
            if (Application.Current?.MainPage is not null)
            {
                if (await Application.Current.MainPage.DisplayAlert("Directory access failed", $"The directory \"{remoteDirectory}\" couldn't be accessed. How do you want to proceed?", "Return to default directory", "Cancel (stay in current directory)"))
                {
                    if (sftpService.Exists(currentSftpConfig.DefaultRemoteDirectory))
                    {
                        await OpenDirectory(currentSftpConfig.DefaultRemoteDirectory);
                        return;
                    }

                    if (sftpService.Exists("."))
                    {
                        await OpenDirectory(".");
                        return;
                    }
                }
                else return;
            }
        }

        currentDirectory = remoteDirectory;

        files = (await sftpService.ListAllAsync(currentDirectory))
            .OrderByDescending(f => f.Name == "..")
            .ThenByDescending(f => f.IsDirectory)
            .ThenBy(f => f.Name);

        await SecureStorage.SetAsync(Constants.PreferenceIds.LAST_DIRECTORY, currentDirectory);
    }

    private bool HasDuplicateFileNames(IEnumerable<FileResult> files)
    {
        return files
            .GroupBy(file => file.FileName)
            .Any(fileGroup => fileGroup.Count() > 1);
    }

    private string GetDuplicateFileNames(IEnumerable<FileResult> files)
    {
        return files
            .GroupBy(file => file.FileName)
            .Where(group => group.Count() > 1)
            .SelectMany(g => g)
            .DistinctBy(f => f.FileName)
            .Select(f => f.FileName)
            .ToCustomCharSeparatedString('\n');
    }

    private async Task OnClickUpload()
    {
        if (busy)
        {
            return;
        }


        busy = true;

        IEnumerable<FileResult> files = await FilePicker.Default.PickMultipleAsync(PickOptions.Default);

        if (!files.Any())
        {
            busy = false;
            return;
        }

        if (HasDuplicateFileNames(files))
        {
            await Application.Current.MainPage.DisplayAlert("Upload failed", $"You selected the following file names more than once:\n\n{GetDuplicateFileNames(files)}\"\n\nDuplicate file names within a single directory are not allowed. Please reselect files with distinct file names.", "OK");
            busy = false;
            return;
        }

        IList<string> fileNameCollisions = new List<string>();

        foreach (SftpFile file in this.files)
        {
            if (files.Any(f => f.FileName == file.Name))
            {
                fileNameCollisions.Add(file.Name);
            }
        }

        bool overwriteExistingFiles = await Application.Current.MainPage.DisplayAlert("File name collisions", "One or more files that you selected have a file name that is already present in the remote directory.\n\nHow do you want to handle these file name collisions?", cancel: "Skip", accept: "Overwrite");

        if (fileNameCollisions.NotNullNotEmpty() && !overwriteExistingFiles)
        {
            files = files.Where(file => !fileNameCollisions.Contains(file.FileName));
        }

        uploadProgress.Clear();

        IList<Task> uploadTasks = new List<Task>();

        foreach (FileResult file in files)
        {
            if (Directory.Exists(file.FullPath)) // Uploading entire directories is not yet supported.
            {
                continue;
            }

            await using Stream fileStream = await file.OpenReadAsync();

            ulong fileSizeBytes = (ulong)fileStream.Length; // Type-casts from hell, uh oh ;D

            uploadProgress[file.FileName] = (0, fileSizeBytes);

            Task uploadTask = sftpService.UploadFileAsync(file.FullPath, $"{currentDirectory.TrimEnd('/').TrimEnd('\\')}/{file.FileName}", overwriteExistingFiles, (ulong progress) =>
            {
                (ulong, ulong) uploadProgressTuple = uploadProgress[file.FileName];

                uploadProgressTuple.Item1 = progress;

                uploadProgress[file.FileName] = uploadProgressTuple;
            });

            uploadTasks.Add(uploadTask);
        }

        _ = Task.Run(async () =>
        {
            while (uploadTasks.NotNullNotEmpty() && uploadTasks.Any(task => !task.IsCompleted))
            {
                await InvokeAsync(StateHasChanged);

                await Task.Delay(256);
            }
        });

        await Task.WhenAll(uploadTasks);

        uploadProgress.Clear();

        busy = false;

        await OpenDirectory(currentDirectory);
    }

    private async Task OnClickCreateDirectory()
    {
        if (sftpService is null || Application.Current?.MainPage is null || busy)
        {
            return;
        }

        string directoryName = await Application.Current.MainPage.DisplayPromptAsync("Enter new directory name", "Enter name for the new directory\n", "Create", "Cancel", keyboard: Keyboard.Text);

        if (directoryName.NullOrEmpty())
        {
            return;
        }

        directoryName = $"{currentDirectory.TrimEnd('/').TrimEnd('\\')}/{directoryName}";

        bool success = sftpService.CreateDirectory(directoryName);

        if (success)
        {
            await OpenDirectory(directoryName);
        }
        else
        {
            await Application.Current.MainPage.DisplayAlert("Directory creation failed", $"Failed to create directory \"{directoryName}\" - perhaps double-check permissions?", "OK");
        }
    }

    private async Task OnClickRename(SftpFile file)
    {
        if (file is null || sftpService is null || Application.Current?.MainPage is null)
        {
            return;
        }

        string objectType = (file.IsDirectory ? "directory" : "file");

        string newName = await Application.Current.MainPage.DisplayPromptAsync($"Enter new {objectType} name", $"Enter new name for \"{file.FullName}\"\n", "Rename", "Cancel", keyboard: Keyboard.Text);

        string newRemotePath = $"{currentDirectory.TrimEnd('/').TrimEnd('\\')}/{newName}";

        if (sftpService.Exists(newRemotePath))
        {
            await Application.Current.MainPage.DisplayAlert($"Renaming {objectType} \"{file.Name}\" failed", $"Failed to rename {objectType} \"{file.Name}\" because there already is a {objectType} with that name under \"{currentDirectory}\"", "OK");
            return;
        }

        if (file.IsRegularFile)
        {
            string ext = Path.GetExtension(file.FullName);
            string newExt = Path.GetExtension(newName);

            if (!ext.Equals(newExt, StringComparison.InvariantCultureIgnoreCase) && !await Application.Current.MainPage.DisplayAlert("File extension mismatch", "You entered a new name whose file extension does not match the previous one. Are you sure that that's you want?", "Proceed", "Cancel"))
            {
                return;
            }

            if (newExt.NullOrEmpty() && !await Application.Current.MainPage.DisplayAlert("File extension?", "You entered a name without a file extension. Are you sure that that's you want?", "Proceed", "Cancel"))
            {
                return;
            }
        }

        bool success = sftpService.Rename(file.FullName, newRemotePath);

        if (success)
        {
            await OpenDirectory(currentDirectory);
        }
        else
        {
            await Application.Current.MainPage.DisplayAlert($"Renaming {objectType} \"{file.Name}\" failed", $"Failed to rename {objectType} \"{file.Name}\" - perhaps double-check permissions?", "OK");
        }
    }

    private async Task OnClickSetPermissions(SftpFile file)
    {
        if (file is null || sftpService is null || Application.Current?.MainPage is null)
        {
            return;
        }

        string chmodString = await Application.Current.MainPage.DisplayPromptAsync("Enter new permission octal", "Enter the new permission set in octal notation (as if you were running \"chmod\" on a *nix server).\n\nE.g. 640, 760, etc...\n", "Save", "Cancel", keyboard: Keyboard.Numeric);

        if (chmodString is null || chmodString.Length != 3 || !short.TryParse(chmodString, out short chmod))
        {
            await Application.Current.MainPage.DisplayAlert("Invalid permission octal", $"The value {chmodString} is not a valid Unix permission octal.\n\nPlease enter a valid value such as 640, 760, etc...\n\nRefer to https://chmod-calculator.com for a simple, learning-by-doing overview of what values are valid here.\n", "OK");
            return;
        }

        switch(chmod)
        {
            case >= 0 and <= 777:
            {
                break;
            }
            default:
            {
                await Application.Current.MainPage.DisplayAlert("Invalid permission octal", $"The value {chmodString} is not a valid Unix permission octal.\n\nPlease enter a valid value such as 640, 760, etc...\n\nRefer to https://chmod-calculator.com for a simple, learning-by-doing overview of what values are valid here.\n", "OK");
                return;
            }
        }

        bool recursively = file.IsDirectory && await Application.Current.MainPage.DisplayAlert("Change directory permissions", $"You're changing permissions for \"{file.FullName}\", which is a directory. Do you want to set the permissions recursively in every subdirectory and files as well, or only this specific directory?\n", "Recursively", "Only this one");

        bool success = sftpService.ChangePermissions(file.FullName, chmod, recursively);

        if (!success)
        {
            await Application.Current.MainPage.DisplayAlert("chmod result", $"One or more files/subdirectories could not be \"chmodded\" into the permissions octal {chmod}", "OK");
        }

        await OpenDirectory(currentDirectory);
    }

    private async Task OnClickDelete(SftpFile file)
    {
        if (file is null || sftpService is null || Application.Current?.MainPage is null)
        {
            return;
        }

        string prompt = (file.IsDirectory ? $"directory \"{file.FullName}\" and all its files and sub-folders" : $"file \"{file.Name}\"");

        if (!await Application.Current.MainPage.DisplayAlert("Are you sure?", $"Do you really want to delete the {prompt}?", "Yes, delete", "No, keep"))
        {
            return;
        }

        if (!sftpService.Delete(file))
        {
            await Application.Current.MainPage.DisplayAlert("Deletion failed", $"Deleting {(file.IsDirectory ? "one or more files/sub-folders inside " : string.Empty)}{file.FullName} failed. Perhaps double-check permissions?", "OK");
            return;
        }

        await OpenDirectory(currentDirectory);
    }
}